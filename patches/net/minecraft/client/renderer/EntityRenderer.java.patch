--- a/net/minecraft/client/renderer/EntityRenderer.java
+++ b/net/minecraft/client/renderer/EntityRenderer.java
@@ -4,15 +4,33 @@
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.nio.FloatBuffer;
+import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.List;
 import java.util.Random;
 import java.util.concurrent.Callable;
+
+import com.mtbs3d.minecrift.CalibrationHelper;
+import com.mtbs3d.minecrift.api.PluginManager;
+import com.mtbs3d.minecrift.control.JoystickAim;
+import com.mtbs3d.minecrift.render.QuaternionHelper;
+import com.mtbs3d.minecrift.settings.VRSettings;
+import com.mtbs3d.minecrift.utils.Utils;
+import de.fruitfly.ovr.OculusRift;
+import de.fruitfly.ovr.enums.Axis;
+import de.fruitfly.ovr.enums.HandedSystem;
+import de.fruitfly.ovr.enums.RotateDirection;
+import de.fruitfly.ovr.structs.EulerOrient;
+import de.fruitfly.ovr.structs.Matrix4f;
+import de.fruitfly.ovr.structs.Quatf;
+import de.fruitfly.ovr.structs.Vector3f;
 import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.audio.SoundManager;
 import net.minecraft.client.entity.EntityPlayerSP;
+import net.minecraft.client.gui.Gui;
 import net.minecraft.client.gui.GuiDownloadTerrain;
 import net.minecraft.client.gui.GuiMainMenu;
 import net.minecraft.client.gui.MapItemRenderer;
@@ -28,6 +46,7 @@
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.IResourceManagerReloadListener;
+import net.minecraft.client.shader.Framebuffer;
 import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.client.shader.ShaderLinkHelper;
 import net.minecraft.crash.CrashReport;
@@ -64,9 +83,17 @@
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.EXTTextureFilterAnisotropic;
 import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL12;
 import org.lwjgl.opengl.GLContext;
 import org.lwjgl.util.glu.Project;
+import org.lwjgl.util.vector.Quaternion;
+import org.lwjgl.util.vector.Vector4f;
+import paulscode.sound.SoundSystem;
+import paulscode.sound.SoundSystemConfig;
+
+import javax.vecmath.Color3f;
 
 public class EntityRenderer implements IResourceManagerReloadListener
 {
@@ -80,7 +107,7 @@
 
     /** A reference to the Minecraft object. */
     private Minecraft mc;
-    private float farPlaneDistance;
+    public float farPlaneDistance;  // Minecrift
     public ItemRenderer itemRenderer;
     private final MapItemRenderer theMapItemRenderer;
 
@@ -157,9 +184,10 @@
     private boolean cloudFog;
     private final IResourceManager resourceManager;
     public ShaderGroup theShaderGroup;
-    private static final ResourceLocation[] shaderResourceLocations = new ResourceLocation[] {new ResourceLocation("shaders/post/notch.json"), new ResourceLocation("shaders/post/fxaa.json"), new ResourceLocation("shaders/post/art.json"), new ResourceLocation("shaders/post/bumpy.json"), new ResourceLocation("shaders/post/blobs2.json"), new ResourceLocation("shaders/post/pencil.json"), new ResourceLocation("shaders/post/color_convolve.json"), new ResourceLocation("shaders/post/deconverge.json"), new ResourceLocation("shaders/post/flip.json"), new ResourceLocation("shaders/post/invert.json"), new ResourceLocation("shaders/post/ntsc.json"), new ResourceLocation("shaders/post/outline.json"), new ResourceLocation("shaders/post/phosphor.json"), new ResourceLocation("shaders/post/scan_pincushion.json"), new ResourceLocation("shaders/post/sobel.json"), new ResourceLocation("shaders/post/bits.json"), new ResourceLocation("shaders/post/desaturate.json"), new ResourceLocation("shaders/post/green.json"), new ResourceLocation("shaders/post/blur.json"), new ResourceLocation("shaders/post/wobble.json"), new ResourceLocation("shaders/post/blobs.json"), new ResourceLocation("shaders/post/antialias.json")};
+    /** Minecrift */
+    public static final ResourceLocation[] shaderResourceLocations = new ResourceLocation[] {new ResourceLocation("shaders/post/notch.json"), new ResourceLocation("shaders/post/fxaa.json"), new ResourceLocation("shaders/post/art.json"), new ResourceLocation("shaders/post/bumpy.json"), new ResourceLocation("shaders/post/blobs2.json"), new ResourceLocation("shaders/post/pencil.json"), new ResourceLocation("shaders/post/color_convolve.json"), new ResourceLocation("shaders/post/deconverge.json"), new ResourceLocation("shaders/post/flip.json"), new ResourceLocation("shaders/post/invert.json"), new ResourceLocation("shaders/post/ntsc.json"), new ResourceLocation("shaders/post/outline.json"), new ResourceLocation("shaders/post/phosphor.json"), new ResourceLocation("shaders/post/scan_pincushion.json"), new ResourceLocation("shaders/post/sobel.json"), new ResourceLocation("shaders/post/bits.json"), new ResourceLocation("shaders/post/desaturate.json"), new ResourceLocation("shaders/post/green.json"), new ResourceLocation("shaders/post/blur.json"), new ResourceLocation("shaders/post/wobble.json"), new ResourceLocation("shaders/post/blobs.json"), new ResourceLocation("shaders/post/antialias.json")};
     public static final int shaderCount = shaderResourceLocations.length;
-    private int shaderIndex;
+    public int shaderIndex;       // TODO: Minecrift - use reflection to access this
     private double cameraZoom;
     private double cameraYaw;
     private double cameraPitch;
@@ -238,7 +266,59 @@
     public long prevFrameTimeNano = -1L;
     private boolean lastShowDebugInfo = false;
     private boolean showExtendedDebugInfo = false;
-    private static final String __OBFID = "CL_00000947";
+
+    /*Minecrift*/
+    public int renderpass = 0;
+    public EulerOrient currentEulerOrientDegrees = new EulerOrient();
+    public boolean sndSystemReflect = true;
+    public boolean guiYawOrientationResetRequested = false;
+    public boolean guiShowingLastFrame = false; //Used for detecting when UI is shown, fixing the guiYaw
+    public boolean guiShowingThisFrame = false;
+    public double renderOriginX;
+    public double renderOriginY;
+    public double renderOriginZ;
+    public Vec3 renderOrigin = Vec3.createVectorHelper(0, 0, 0);
+    public double cameraRoll;
+    public float headYaw = 0.0F; //relative to head tracker reference frame, absolute
+    public float headPitch = 0.0F;
+    public float headRoll = 0.0F;
+    public float prevHeadYaw = 0.0F;
+    public float prevHeadPitch = 0.0F;
+    public float prevHeadRoll = 0.0F;
+    public float guiHeadYaw = 0.0f; //Not including mouse
+    public float camRelX;
+    public float camRelY;
+    public float camRelZ;
+    public float crossX;
+    public float crossY;
+    public float crossZ;
+    public float lookX; //In world coordinates
+    public float lookY;
+    public float lookZ;
+    public float aimX; //In world coordinates
+    public float aimY;
+    public float aimZ;
+    public float aimYaw;
+    public float aimPitch;
+    public CalibrationHelper calibrationHelper;
+    public float INITIAL_CALIBRATION_TEXT_SCALE = 0.0065f;
+    public int CALIBRATION_TEXT_WORDWRAP_LEN = 40;
+    public boolean headCollision = false;
+    public float headCollisionThresholdDistance = 0.05f;
+    public float headCollisionDistance = -1f;
+    public Field _soundManagerSndSystemField = null;
+    public float clipDistance = 0f;
+    public float minClipDistance = 0.05f;
+    public boolean[] generatedIconMipmaps = new boolean[2];
+    public Matrix4f[] eyeproj = new Matrix4f[2];
+    public boolean trySoundSystemReflect = true;
+    public Vec3 aimStartPos = null;
+    public Vec3 aimEndPos = null;
+    public Vec3 aimRenderOrigin = null;
+    public float lookYawOffset = 0;
+    public float lookPitchOffset = 0;
+    public int callCount = 0;
+    /** end Minecrift **/
 
     public EntityRenderer(Minecraft p_i45076_1_, IResourceManager p_i45076_2_)
     {
@@ -255,6 +335,14 @@
         this.locationLightMap = p_i45076_1_.getTextureManager().getDynamicTextureLocation("lightMap", this.lightmapTexture);
         this.lightmapColors = this.lightmapTexture.getTextureData();
         this.theShaderGroup = null;
+
+        // Minecrift
+        generatedIconMipmaps[0] = false;
+        generatedIconMipmaps[1] = false;
+        eyeproj[0] = new Matrix4f();
+        eyeproj[1] = new Matrix4f();
+        if (this.mc.vrSettings.calibrationStrategy == VRSettings.CALIBRATION_STRATEGY_AT_STARTUP)
+            startCalibration();
     }
 
     public boolean isShaderActive()
@@ -277,39 +365,43 @@
     {
         if (OpenGlHelper.shadersSupported)
         {
-            if (this.theShaderGroup != null)
-            {
-                this.theShaderGroup.deleteShaderGroup();
-            }
-
             this.shaderIndex = (this.shaderIndex + 1) % (shaderResourceLocations.length + 1);
+/** Minecrift **/
+            // The change will be picked up the next time round the render loop...
+        }
+    }
 
-            if (this.shaderIndex != shaderCount)
+    public ShaderGroup initShaderGroup(Framebuffer framebuffer)
+    {
+        ShaderGroup shaderGroup = null;
+
+        if (OpenGlHelper.shadersSupported && this.shaderIndex != shaderCount)
+        {
+            try
             {
-                try
-                {
-                    logger.info("Selecting effect " + shaderResourceLocations[this.shaderIndex]);
-                    this.theShaderGroup = new ShaderGroup(this.mc.getTextureManager(), this.resourceManager, this.mc.getFramebuffer(), shaderResourceLocations[this.shaderIndex]);
-                    this.theShaderGroup.createBindFramebuffers(this.mc.displayWidth, this.mc.displayHeight);
-                }
+                logger.info("Selecting effect " + shaderResourceLocations[this.shaderIndex]);
+                shaderGroup = new ShaderGroup(this.mc.getTextureManager(), this.resourceManager, framebuffer, shaderResourceLocations[this.shaderIndex]);
+                shaderGroup.createBindFramebuffers(this.mc.displayWidth, this.mc.displayHeight);
+            }
                 catch (IOException var2)
-                {
+            {
                     logger.warn("Failed to load shader: " + shaderResourceLocations[this.shaderIndex], var2);
-                    this.shaderIndex = shaderCount;
-                }
-                catch (JsonSyntaxException var3)
-                {
-                    logger.warn("Failed to load shader: " + shaderResourceLocations[this.shaderIndex], var3);
-                    this.shaderIndex = shaderCount;
-                }
+                this.shaderIndex = shaderCount;
             }
-            else
+                catch (JsonSyntaxException var3)
             {
-                this.theShaderGroup = null;
-                logger.info("No effect selected");
+                    logger.warn("Failed to load shader: " + shaderResourceLocations[this.shaderIndex], var3);
+                this.shaderIndex = shaderCount;
             }
         }
+        else
+        {
+            logger.info("No effect selected");
+        }
+
+        return shaderGroup;
     }
+/** end Minecrift **/	
 
     public void onResourceManagerReload(IResourceManager par1ResourceManager)
     {
@@ -414,41 +506,85 @@
      */
     public void getMouseOver(float par1)
     {
+        //No-op for performance reasons (MouseOver set in render loop via getPointedBlock)
+    }
+
+    public Vec3 getEyeCentrePosInWorldFrame()
+    {
+        Vec3 basePosition = Vec3.createVectorHelper(0f, -(Minecraft.getMinecraft().vrSettings.getPlayerEyeHeight() - 1.62f), 0f);
+        Vec3 centerEyePos = mc.positionTracker.getCenterEyePosition();  // Get center eye, so it is the same point for each eye render...
+        centerEyePos.zCoord += -Minecraft.getMinecraft().vrSettings.eyeProtrusion;
+        centerEyePos.rotateAroundX(-lookPitchOffset * this.mc.PIOVER180);
+        centerEyePos.rotateAroundY(-lookYawOffset   * this.mc.PIOVER180);
+        Vec3 centerEyePosOffset = centerEyePos.addVector(basePosition.xCoord, basePosition.yCoord, basePosition.zCoord);
+        return Vec3.createVectorHelper(-centerEyePosOffset.xCoord, -centerEyePosOffset.yCoord, -centerEyePosOffset.zCoord); // TODO: Why negated?
+    }
+
+    public void getPointedBlock(float par1)
+    {
         if (this.mc.renderViewEntity != null && this.mc.theWorld != null)
         {
+            // Lets choose to use the head position for block / entity distance hit / miss calcs for now. Lean
+            // forward, you can hit further away...
+
             this.mc.pointedEntity = null;
-            double var2 = (double)this.mc.playerController.getBlockReachDistance();
-            this.mc.objectMouseOver = this.mc.renderViewEntity.rayTrace(var2, par1);
-            double var4 = var2;
-            Vec3 var6 = this.mc.renderViewEntity.getPosition(par1);
+            double blockReachDistance = (double)this.mc.playerController.getBlockReachDistance();
+            double entityReachDistance = blockReachDistance;
+            Vec3 centerEyePosOffset = getEyeCentrePosInWorldFrame();
+
+            // Darktemp's crosshair fix
+            Vec3 pos1 = renderOrigin.addVector(centerEyePosOffset.xCoord, centerEyePosOffset.yCoord, centerEyePosOffset.zCoord);
+            Vec3 pos2 = renderOrigin.addVector(centerEyePosOffset.xCoord, centerEyePosOffset.yCoord, centerEyePosOffset.zCoord);
+            Vec3 pos3 = renderOrigin.addVector(centerEyePosOffset.xCoord, centerEyePosOffset.yCoord, centerEyePosOffset.zCoord);
+            Vec3 aim = Vec3.createVectorHelper(aimX, aimY, aimZ);
 
             if (this.mc.playerController.extendedReach())
             {
-                var2 = 6.0D;
-                var4 = 6.0D;
+                blockReachDistance = 6.0D;
+                entityReachDistance = 6.0D;
             }
             else
             {
-                if (var2 > 3.0D)
+                if (blockReachDistance > 3.0D)
                 {
-                    var4 = 3.0D;
+                    entityReachDistance = 3.0D;
                 }
 
-                var2 = var4;
+                blockReachDistance = entityReachDistance;
             }
 
-            if (this.mc.objectMouseOver != null)
+            Vec3 endPos = pos1.addVector(aim.xCoord*blockReachDistance,aim.yCoord*blockReachDistance ,aim.zCoord*blockReachDistance );
+            this.mc.objectMouseOver = this.mc.theWorld.func_147447_a(pos1, endPos, false, false, true);
+
+            Vec3 crossVec=pos1.addVector(aim.xCoord*blockReachDistance,aim.yCoord*blockReachDistance ,aim.zCoord*blockReachDistance );
+            if (this.mc.objectMouseOver == null || this.mc.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.MISS)
             {
-                var4 = this.mc.objectMouseOver.hitVec.distanceTo(var6);
+                // Get MISS distance
+                if (!this.mc.vrSettings.maxCrosshairDistanceAtBlockReach) {
+                    endPos = pos2.addVector(aim.xCoord * 128, aim.yCoord * 128, aim.zCoord * 128);
+                    MovingObjectPosition crossPos = this.mc.theWorld.func_147447_a(pos2, endPos, false, false, true);
+                    if (crossPos != null) {
+                        crossVec = crossPos.hitVec;
+                    } else {
+                        crossVec = Vec3.createVectorHelper(endPos.xCoord, endPos.yCoord, endPos.zCoord);
+                    }
+                }
+                this.mc.objectMouseOver = null;
+            }
+            else
+            {
+                // Get HIT distance
+                entityReachDistance = this.mc.objectMouseOver.hitVec.distanceTo(pos2); // Set entityreach here - we can't hit an entity behind whatever this is...
+                crossVec = this.mc.objectMouseOver.hitVec;
             }
 
-            Vec3 var7 = this.mc.renderViewEntity.getLook(par1);
-            Vec3 var8 = var6.addVector(var7.xCoord * var2, var7.yCoord * var2, var7.zCoord * var2);
+            Vec3 otherpos = mc.renderViewEntity.getPosition(par1);
+            Vec3 var8 = otherpos.addVector(aim.xCoord * blockReachDistance, aim.yCoord * blockReachDistance, aim.zCoord * blockReachDistance);
             this.pointedEntity = null;
             Vec3 var9 = null;
-            float var10 = 1.0F;
-            List var11 = this.mc.theWorld.getEntitiesWithinAABBExcludingEntity(this.mc.renderViewEntity, this.mc.renderViewEntity.boundingBox.addCoord(var7.xCoord * var2, var7.yCoord * var2, var7.zCoord * var2).expand((double)var10, (double)var10, (double)var10));
-            double var12 = var4;
+            float var10 = 1.0F;  // TODO: This should probably be the max coord of centerEyePosOffset
+            List var11 = this.mc.theWorld.getEntitiesWithinAABBExcludingEntity(this.mc.renderViewEntity, this.mc.renderViewEntity.boundingBox.addCoord(aim.xCoord * blockReachDistance, aim.yCoord * blockReachDistance, aim.zCoord * blockReachDistance).expand((double)var10, (double)var10, (double)var10));
+            double var12 = entityReachDistance;
 
             for (int var14 = 0; var14 < var11.size(); ++var14)
             {
@@ -458,20 +594,20 @@
                 {
                     float var16 = var15.getCollisionBorderSize();
                     AxisAlignedBB var17 = var15.boundingBox.expand((double)var16, (double)var16, (double)var16);
-                    MovingObjectPosition var18 = var17.calculateIntercept(var6, var8);
+                    MovingObjectPosition var18 = var17.calculateIntercept(pos3, var8);
 
-                    if (var17.isVecInside(var6))
+                    if (var17.isVecInside(pos3))
                     {
                         if (0.0D < var12 || var12 == 0.0D)
                         {
                             this.pointedEntity = var15;
-                            var9 = var18 == null ? var6 : var18.hitVec;
+                            var9 = var18 == null ? pos3 : var18.hitVec;
                             var12 = 0.0D;
                         }
                     }
                     else if (var18 != null)
                     {
-                        double var19 = var6.distanceTo(var18.hitVec);
+                        double var19 = pos3.distanceTo(var18.hitVec);
 
                         if (var19 < var12 || var12 == 0.0D)
                         {
@@ -501,15 +637,40 @@
                 }
             }
 
-            if (this.pointedEntity != null && (var12 < var4 || this.mc.objectMouseOver == null))
-            {
+            if (this.pointedEntity != null && (var12 < entityReachDistance || this.mc.objectMouseOver == null)) {
                 this.mc.objectMouseOver = new MovingObjectPosition(this.pointedEntity, var9);
+                crossVec = this.mc.objectMouseOver.hitVec;
 
-                if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame)
-                {
+                if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame) {
                     this.mc.pointedEntity = this.pointedEntity;
                 }
             }
+
+            // Set up crosshair position
+            float SLIGHTLY_CLOSER = 0.001f;
+            Vec3 centerEyePosToCrossDirection = pos3.subtract(crossVec).normalize();
+            crossX = (float)(crossVec.xCoord - (centerEyePosToCrossDirection.xCoord*SLIGHTLY_CLOSER) - renderOriginX);
+            crossY = (float)(crossVec.yCoord - (centerEyePosToCrossDirection.yCoord*SLIGHTLY_CLOSER) - renderOriginY);
+            crossZ = (float)(crossVec.zCoord - (centerEyePosToCrossDirection.zCoord*SLIGHTLY_CLOSER) - renderOriginZ);
+
+            if (this.mc.vrSettings.storeDebugAim)
+            {
+                Vec3 cross = Vec3.createVectorHelper(crossX, crossY, crossZ);
+                double crossDist = cross.lengthVector();
+                Vec3 posDebug = Vec3.createVectorHelper(centerEyePosOffset.xCoord, centerEyePosOffset.yCoord, centerEyePosOffset.zCoord);
+                Vec3 endPosDebug = posDebug.addVector(aim.xCoord*crossDist,aim.yCoord*crossDist ,aim.zCoord*crossDist );
+                this.mc.vrSettings.storeDebugAim = false;
+                this.aimStartPos = posDebug;
+                this.aimEndPos = endPosDebug;
+                this.aimRenderOrigin = renderOrigin;
+
+                if (this.mc.objectMouseOver == null || this.mc.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.MISS) {
+                    this.mc.printChatMessage("MISS: Cross dist=" + crossDist);
+                }
+                else {
+                    this.mc.printChatMessage("HIT: Cross dist=" + crossDist + ", Object=" + this.mc.objectMouseOver.toString());
+                }
+            }
         }
     }
 
@@ -562,6 +723,7 @@
                 var4 *= this.fovModifierHandPrev + (this.fovModifierHand - this.fovModifierHandPrev) * par1;
             }
 
+			// TODO: Minecrift - may need to disable this zoom effect
             boolean zoomActive = false;
 
             if (this.mc.currentScreen == null)
@@ -646,9 +808,11 @@
         {
             EntityPlayer var2 = (EntityPlayer)this.mc.renderViewEntity;
             float var3 = var2.distanceWalkedModified - var2.prevDistanceWalkedModified;
-            float var4 = -(var2.distanceWalkedModified + var3 * par1);
-            float var5 = var2.prevCameraYaw + (var2.cameraYaw - var2.prevCameraYaw) * par1;
-            float var6 = var2.prevCameraPitch + (var2.cameraPitch - var2.prevCameraPitch) * par1;
+            /** Minecrift */       // TODO: Tweak this
+            float var4 = -(var2.distanceWalkedModified + var3 * par1) * this.mc.vrSettings.movementSpeedMultiplier;
+            float var5 = var2.prevCameraYaw + (var2.cameraYaw - var2.prevCameraYaw) * par1 * this.mc.vrSettings.movementSpeedMultiplier;
+            float var6 = var2.prevCameraPitch + (var2.cameraPitch - var2.prevCameraPitch) * par1 * this.mc.vrSettings.movementSpeedMultiplier;
+            /** end Minecrift */
             GL11.glTranslatef(MathHelper.sin(var4 * (float)Math.PI) * var5 * 0.5F, -Math.abs(MathHelper.cos(var4 * (float)Math.PI) * var5), 0.0F);
             GL11.glRotatef(MathHelper.sin(var4 * (float)Math.PI) * var5 * 3.0F, 0.0F, 0.0F, 1.0F);
             GL11.glRotatef(Math.abs(MathHelper.cos(var4 * (float)Math.PI - 0.2F) * var5) * 5.0F, 1.0F, 0.0F, 0.0F);
@@ -666,7 +830,7 @@
         double var4 = var2.prevPosX + (var2.posX - var2.prevPosX) * (double)par1;
         double var6 = var2.prevPosY + (var2.posY - var2.prevPosY) * (double)par1 - (double)var3;
         double var8 = var2.prevPosZ + (var2.posZ - var2.prevPosZ) * (double)par1;
-        GL11.glRotatef(this.prevCamRoll + (this.camRoll - this.prevCamRoll) * par1, 0.0F, 0.0F, 1.0F);
+        //GL11.glRotatef(this.prevCamRoll + (this.camRoll - this.prevCamRoll) * p_78467_1_, 0.0F, 0.0F, 1.0F);  // TODO: Minecrift
 
         if (var2.isPlayerSleeping())
         {
@@ -755,16 +919,38 @@
         }
         else
         {
-            GL11.glTranslatef(0.0F, 0.0F, -0.1F);
+//            GL11.glTranslatef(0.0F, 0.0F, -0.1F);  // TODO: Minecrift
         }
 
-        if (!this.mc.gameSettings.debugCamEnable)
-        {
-            GL11.glRotatef(var2.prevRotationPitch + (var2.rotationPitch - var2.prevRotationPitch) * par1, 1.0F, 0.0F, 0.0F);
-            GL11.glRotatef(var2.prevRotationYaw + (var2.rotationYaw - var2.prevRotationYaw) * par1 + 180.0F, 0.0F, 1.0F, 0.0F);
-        }
+        // Minecrift - view adjust for IPD etc.
+        GL11.glTranslatef(-this.mc.vrSettings.getHalfIPD(this.mc.currentEye) * this.mc.vrSettings.ipdScale,
+                          this.mc.eyeRenderParams.Eyes[this.mc.currentEye.value()].ViewAdjust.y,
+                          Math.abs(this.mc.eyeRenderParams.Eyes[this.mc.currentEye.value()].ViewAdjust.z * this.mc.vrSettings.ipdScale));  // TODO: Does z need to be minus? Also x pos track scale?
+                //this.mc.vrSettings.eyeRelief);
+
+        // Minecrift - orientation
+        if (this.mc.gameSettings.thirdPersonView == 2)
+            GL11.glRotatef((float) -this.headRoll, 0.0F, 0.0F, 1.0F);
+        else
+            GL11.glRotatef((float) this.headRoll,  0.0F, 0.0F, 1.0F);
+        GL11.glRotatef((float) this.headPitch,     1.0F, 0.0F, 0.0F);
+        GL11.glRotatef((float) this.headYaw,       0.0F, 1.0F, 0.0F);
+
+        // Minecrift - pos
+        GL11.glTranslatef(camRelX,
+                          camRelY,
+                          camRelZ + Minecraft.getMinecraft().vrSettings.eyeProtrusion);
+
+        // Minecrift - correct for yaw / pitch offsets
+        GL11.glRotatef(this.lookPitchOffset, 1.0F, 0.0F, 0.0F);
+        GL11.glRotatef(this.lookYawOffset,   0.0F, 1.0F, 0.0F);
+
+        // Account for player eye height
+        GL11.glTranslatef(0f, -(Minecraft.getMinecraft().vrSettings.getPlayerEyeHeight() - 1.62f), 0f);
+
+        // Minecrift - rotate 180 to correct walk / strafe direction(!)
+        GL11.glRotatef(180f, 0f, 1f, 0f);
 
-        GL11.glTranslatef(0.0F, var3, 0.0F);
         var4 = var2.prevPosX + (var2.posX - var2.prevPosX) * (double)par1;
         var6 = var2.prevPosY + (var2.posY - var2.prevPosY) * (double)par1 - (double)var3;
         var8 = var2.prevPosZ + (var2.posZ - var2.prevPosZ) * (double)par1;
@@ -776,17 +962,7 @@
      */
     private void setupCameraTransform(float par1, int par2)
     {
-        this.farPlaneDistance = (float)(this.mc.gameSettings.renderDistanceChunks * 16);
-
-        if (Config.isFogFancy())
-        {
-            this.farPlaneDistance *= 0.95F;
-        }
-
-        if (Config.isFogFast())
-        {
-            this.farPlaneDistance *= 0.83F;
-        }
+        // Setup fog in Minecraft.setupRenderConfig
 
         GL11.glMatrixMode(GL11.GL_PROJECTION);
         GL11.glLoadIdentity();
@@ -797,25 +973,24 @@
             GL11.glTranslatef((float)(-(par2 * 2 - 1)) * var3, 0.0F, 0.0F);
         }
 
-        float clipDistance = this.farPlaneDistance * 2.0F;
-
-        if (clipDistance < 128.0F)
+        if (this.cameraZoom != 1.0D)
         {
-            clipDistance = 128.0F;
+            GL11.glTranslatef((float)this.cameraYaw, (float)(-this.cameraPitch), (float)(-this.cameraRoll)); // Minecrift
+            GL11.glScaled(this.cameraZoom, this.cameraZoom, 1.0D);
         }
 
-        if (this.mc.theWorld.provider.dimensionId == 1)
+        // Minecrift - use correct projection
+        if (this.mc.renderStereo)
         {
-            clipDistance = 256.0F;
+            GL11.glMultMatrix(eyeproj[this.mc.currentEye.value()].transposed().toFloatBuffer());
         }
-
-        if (this.cameraZoom != 1.0D)
+        else
         {
-            GL11.glTranslatef((float)this.cameraYaw, (float)(-this.cameraPitch), 0.0F);
-            GL11.glScaled(this.cameraZoom, this.cameraZoom, 1.0D);
+            Project.gluPerspective(this.getFOVModifier(par1, true), (float) this.mc.displayWidth / (float) this.mc.displayHeight, minClipDistance, clipDistance);
         }
+        // end Minecrift
+		
 
-        Project.gluPerspective(this.getFOVModifier(par1, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, clipDistance);
         float var4;
 
         if (this.mc.playerController.enableEverythingIsScrewedUpMode())
@@ -832,7 +1007,7 @@
             GL11.glTranslatef((float)(par2 * 2 - 1) * 0.1F, 0.0F, 0.0F);
         }
 
-        this.hurtCameraEffect(par1);
+        this.hurtCameraEffect(par2);
 
         if (this.mc.gameSettings.viewBobbing)
         {
@@ -852,6 +1027,7 @@
 
             float var6 = 5.0F / (var4 * var4 + 5.0F) - var4 * 0.04F;
             var6 *= var6;
+		    // TODO: Minecrift - enable blanking
             GL11.glRotatef(((float)this.rendererUpdateCount + par1) * (float)var7, 0.0F, 1.0F, 1.0F);
             GL11.glScalef(1.0F / var6, 1.0F, 1.0F);
             GL11.glRotatef(-((float)this.rendererUpdateCount + par1) * (float)var7, 0.0F, 1.0F, 1.0F);
@@ -859,6 +1035,8 @@
 
         this.orientCamera(par1);
 
+		// TODO: Minecrift
+		/*
         if (this.debugViewDirection > 0)
         {
             int var71 = this.debugViewDirection - 1;
@@ -887,7 +1065,7 @@
             {
                 GL11.glRotatef(-90.0F, 1.0F, 0.0F, 0.0F);
             }
-        }
+        }*/
     }
 
     /**
@@ -981,8 +1159,6 @@
         GL11.glTranslatef(8.0F, 8.0F, 8.0F);
         GL11.glMatrixMode(GL11.GL_MODELVIEW);
         this.mc.getTextureManager().bindTexture(this.locationLightMap);
-        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
-        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
         GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_CLAMP);
         GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_CLAMP);
         GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
@@ -1222,37 +1398,60 @@
             this.prevFrameTime = Minecraft.getSystemTime();
         }
 
-        this.mc.mcProfiler.startSection("mouse");
-
-        if (this.mc.inGameHasFocus && var21)
-        {
-            this.mc.mouseHelper.mouseXYChange();
-            float var132 = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
-            float var141 = var132 * var132 * var132 * 8.0F;
-            float var15 = (float)this.mc.mouseHelper.deltaX * var141;
-            float var16 = (float)this.mc.mouseHelper.deltaY * var141;
-            byte var17 = 1;
-
-            if (this.mc.gameSettings.invertMouse)
-            {
-                var17 = -1;
-            }
-
-            if (this.mc.gameSettings.smoothCamera)
-            {
-                this.smoothCamYaw += var15;
-                this.smoothCamPitch += var16;
-                float var18 = par1 - this.smoothCamPartialTicks;
-                this.smoothCamPartialTicks = par1;
-                var15 = this.smoothCamFilterX * var18;
-                var16 = this.smoothCamFilterY * var18;
-                this.mc.thePlayer.setAngles(var15, var16 * (float)var17);
-            }
-            else
-            {
-                this.mc.thePlayer.setAngles(var15, var16 * (float)var17);
-            }
-        }
+        //Update gui Yaw      // TODO: Is this needed for anything else? This doesn't work if in
+                              // game, no HUD displayed - menu appears in the wrong place (-current headYaw)
+//        if( guiShowingThisFrame && !guiShowingLastFrame )
+//        {
+//            guiHeadYaw = (float)this.cameraYaw - this.mc.lookaimController.getBodyYawDegrees();
+//        }
+        guiShowingLastFrame = guiShowingThisFrame;
+//        this.mc.mcProfiler.startSection("mouse");
+//
+////        if (this.mc.inGameHasFocus && var21)
+////        {
+////            this.mc.mouseHelper.mouseXYChange();
+////            float var132 = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
+////            float var141 = var132 * var132 * var132 * 8.0F;
+////            float var15 = (float)this.mc.mouseHelper.deltaX * var141;
+////            float var16 = (float)this.mc.mouseHelper.deltaY * var141;
+////            byte var17 = 1;
+////
+////            if (this.mc.gameSettings.invertMouse)
+////            {
+////                var17 = -1;
+////            }
+////
+////            if (!this.mc.renderStereo)
+////            {
+////                if (this.mc.gameSettings.smoothCamera)
+////                {
+////                this.smoothCamYaw += var15;
+////                this.smoothCamPitch += var16;
+////                float var18 = par1 - this.smoothCamPartialTicks;
+////                this.smoothCamPartialTicks = par1;
+////                var15 = this.smoothCamFilterX * var18;
+////                var16 = this.smoothCamFilterY * var18;
+////                this.mc.thePlayer.setAngles(var15, var16 * (float)var17);
+////                }
+////                else
+////                {
+////                this.mc.thePlayer.setAngles(var15, var16 * (float)var17);
+////                }
+////            }
+////            else
+////            {
+////                currentEulerOrientDegrees = OculusRift.getEulerAnglesDeg(this.mc.currentPose.Orientation,
+////                        1.0f,
+////                        Axis.Axis_Y,
+////                        Axis.Axis_X,
+////                        Axis.Axis_Z,
+////                        HandedSystem.Handed_L,
+////                        RotateDirection.Rotate_CCW);
+////
+////                this.mc.thePlayer.rotationYaw = currentEulerOrientDegrees.yaw;
+////                this.mc.thePlayer.rotationPitch = currentEulerOrientDegrees.pitch;
+////            }
+////        }
 
         this.mc.mcProfiler.endSection();
 
@@ -1268,6 +1467,8 @@
 
             if (this.mc.theWorld != null)
             {
+                // In the world...
+
                 this.mc.mcProfiler.startSection("level");
 
                 if (this.mc.isFramerateLimitBelowMax())
@@ -1288,6 +1489,7 @@
                         GL11.glLoadIdentity();
                         this.theShaderGroup.loadShaderGroup(par1);
                         GL11.glPopMatrix();
+                        GL11.glMatrixMode(GL11.GL_MODELVIEW);
                     }
 
                     this.mc.getFramebuffer().bindFramebuffer(true);
@@ -1296,26 +1498,46 @@
                 this.renderEndNanoTime = System.nanoTime();
                 this.mc.mcProfiler.endStartSection("gui");
 
-                if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null)
-                {
-                    GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
-                    this.mc.ingameGUI.renderGameOverlay(par1, this.mc.currentScreen != null, var161, var171);
+                if (!this.mc.renderStereo)
+				{
+                    if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null) 
+					{
+                        GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+                    	this.mc.ingameGUI.renderGameOverlay(par1, this.mc.currentScreen != null, var161, var171);
+                    }
                 }
 
                 this.mc.mcProfiler.endSection();
             }
             else
             {
-                GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-                GL11.glMatrixMode(GL11.GL_PROJECTION);
-                GL11.glLoadIdentity();
-                GL11.glMatrixMode(GL11.GL_MODELVIEW);
-                GL11.glLoadIdentity();
-                this.setupOverlayRendering();
+                // Gui Main Menus...
+                GL11.glClearColor(1f, 1f, 1f, 1f);
+                GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);            // Clear Screen And Depth Buffer on the framebuffer to black
+                GL11.glDisable(GL11.GL_BLEND);
+
+//                if (!this.mc.renderStereo)
+//                {
+//                    GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+//                    GL11.glMatrixMode(GL11.GL_PROJECTION);
+//                    GL11.glLoadIdentity();
+//                    GL11.glMatrixMode(GL11.GL_MODELVIEW);
+//                    GL11.glLoadIdentity();
+//                    this.setupOverlayRendering();
+//                }
                 this.renderEndNanoTime = System.nanoTime();
             }
 
-            if (this.mc.currentScreen != null)
+            if (this.mc.renderStereo)
+            {
+                renderPositionalTrackFade();
+
+                GL11.glEnable(GL11.GL_ALPHA_TEST);
+                GL11.glEnable(GL11.GL_DEPTH_TEST);
+
+                renderGuiLayer();
+            }
+            else if (this.mc.currentScreen != null)
             {
                 GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
 
@@ -1342,41 +1564,26 @@
                     var11.addCrashSectionCallable("Screen name", new Callable()
                     {
                         private static final String __OBFID = "CL_00000948";
-                        private static final String __OBFID = "CL_00000948";
                         public String call()
                         {
                             return EntityRenderer.this.mc.currentScreen.getClass().getCanonicalName();
                         }
-                        public Object call() throws Exception
-                        {
-                            return this.call();
-                        }
                     });
                     var11.addCrashSectionCallable("Mouse location", new Callable()
                     {
                         private static final String __OBFID = "CL_00000950";
-                        private static final String __OBFID = "CL_00000950";
                         public String call()
                         {
                             return String.format("Scaled: (%d, %d). Absolute: (%d, %d)", new Object[] {Integer.valueOf(var161), Integer.valueOf(var171), Integer.valueOf(Mouse.getX()), Integer.valueOf(Mouse.getY())});
                         }
-                        public Object call() throws Exception
-                        {
-                            return this.call();
-                        }
                     });
                     var11.addCrashSectionCallable("Screen size", new Callable()
                     {
                         private static final String __OBFID = "CL_00000951";
-                        private static final String __OBFID = "CL_00000951";
                         public String call()
                         {
                             return String.format("Scaled: (%d, %d). Absolute: (%d, %d). Scale factor of %d", new Object[] {Integer.valueOf(var133.getScaledWidth()), Integer.valueOf(var133.getScaledHeight()), Integer.valueOf(EntityRenderer.this.mc.displayWidth), Integer.valueOf(EntityRenderer.this.mc.displayHeight), Integer.valueOf(var133.getScaleFactor())});
                         }
-                        public Object call() throws Exception
-                        {
-                            return this.call();
-                        }
                     });
                     throw new ReportedException(var10);
                 }
@@ -1401,6 +1608,299 @@
             this.mc.gameSettings.showDebugProfilerChart = true;
         }
     }
+	
+	public void renderGuiLayer()
+	{
+		if (this.guiShowingThisFrame)
+        {
+            GL11.glDisable(GL11.GL_CULL_FACE);
+            GL11.glEnable(GL11.GL_TEXTURE_2D);
+            this.mc.guiFramebuffer.bindFramebufferTexture();
+            //this.mc.getTextureManager().bindTexture(Gui.icons);
+
+            // Prevent black border at top / bottom of GUI
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+
+            // Set texture filtering
+            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
+            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, 16.0f);
+
+            //eyeproj = this.mc.stereoProvider.getMatrix4fProjection(this.mc.eyeRenderParams.Eyes[this.mc.currentEye.value()].Fov, minClipDistance, clipDistance);
+
+            // Pass matrici on to OpenGL...
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPushMatrix();
+            GL11.glLoadIdentity();
+            GL11.glMultMatrix(eyeproj[this.mc.currentEye.value()].transposed().toFloatBuffer());     // Needs eyeProj to have been setup previously
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPushMatrix();
+            GL11.glLoadIdentity();
+
+            if (this.mc.theWorld != null && this.mc.vrSettings.hudLockToHead)
+            {
+                GL11.glRotatef(180f - this.mc.vrSettings.hudYawOffset, 0f, 1f, 0f);        // TODO: What's *this* 180 for?
+                GL11.glRotatef(-this.mc.vrSettings.hudPitchOffset, 1f, 0f, 0f);
+                //GL11.glRotatef(cameraRoll, 0f, 0f, 1f);
+
+                GL11.glTranslatef(0.0f, 0.0f, this.mc.vrSettings.hudDistance - this.mc.vrSettings.eyeProtrusion);
+                GL11.glRotatef(180f, 0f, 1f, 0f);//Not sure why this is necessary... normals/backface culling maybe?    // TODO: Another 180!
+            }
+            else
+            {
+//                float guiYaw = 0f;
+//                if (this.mc.theWorld != null && this.mc.vrSettings.lookMoveDecoupled)
+//                {
+//                    guiYaw = this.mc.lookaimController.getBodyYawDegrees();
+//                }
+//                else
+//                {
+//                    guiYaw = guiHeadYaw + this.mc.lookaimController.getBodyYawDegrees();
+//                }
+//
+//                float guiPitch = 0f;
+//
+////                    if( this.mc.vrSettings.allowMousePitchInput)
+////                        guiPitch += this.mc.lookaimController.getBodyPitchDegrees();
+//
+//                // View adjust for IPD etc.
+//                GL11.glTranslated(-this.mc.vrSettings.getHalfIPD(this.mc.currentEye) * this.mc.vrSettings.ipdScale,
+//                        this.mc.eyeRenderParams.Eyes[this.mc.currentEye.value()].ViewAdjust.y,
+//                        this.mc.eyeRenderParams.Eyes[this.mc.currentEye.value()].ViewAdjust.z);  // TODO: Does Z need to be minus?
+//
+//                // Orientation adjust
+//                GL11.glRotatef((float)cameraRoll, 0f, 0f, 1f);
+//                GL11.glRotatef((float)cameraPitch - guiPitch, 1f, 0f, 0f);
+//                GL11.glRotatef((float)cameraYaw - guiYaw, 0f, 1f, 0f);
+//
+//                // Rotate our position data
+//                Vec3 pos = Vec3.createVectorHelper(-camRelX, camRelY, -camRelZ);
+//
+//                pos.rotateAroundX(-guiPitch*this.mc.PIOVER180);
+//                pos.rotateAroundY(guiYaw*this.mc.PIOVER180);
+//
+//                // Position adjust
+//                GL11.glTranslated(pos.xCoord, pos.yCoord, pos.zCoord);
+//
+//                GL11.glRotatef(-this.mc.vrSettings.hudPitchOffset, 1f, 0f, 0f);
+//                GL11.glRotatef(-this.mc.vrSettings.hudYawOffset, 0f, 1f, 0f);
+//                GL11.glTranslatef(0.0f, 0.0f, -this.mc.vrSettings.hudDistance);
+
+                float guiYaw = 0f;
+                if (this.mc.theWorld != null && this.mc.vrSettings.lookMoveDecoupled)
+                {
+                    guiYaw = this.mc.lookaimController.getBodyYawDegrees();
+                }
+                else
+                {
+                    guiYaw = guiHeadYaw + this.mc.lookaimController.getBodyYawDegrees();
+                }
+
+                float guiPitch = 0f;
+
+//                    if( this.mc.vrSettings.allowMousePitchInput)
+//                        guiPitch += this.mc.lookaimController.getBodyPitchDegrees();
+
+                // View adjust for IPD etc.
+                GL11.glTranslatef(-this.mc.vrSettings.getHalfIPD(this.mc.currentEye) * this.mc.vrSettings.ipdScale,
+                                  this.mc.eyeRenderParams.Eyes[this.mc.currentEye.value()].ViewAdjust.y,
+                                  Math.abs(this.mc.eyeRenderParams.Eyes[this.mc.currentEye.value()].ViewAdjust.z));  // TODO: Does Z need to be minus?
+
+                //System.out.println("ViewAdjust (" + this.mc.currentEye.toString() + "): " + this.mc.eyeRenderParams.Eyes[this.mc.currentEye.value()].ViewAdjust.z);
+
+                // Orientation adjust
+                GL11.glRotatef((float)headRoll, 0f, 0f, 1f);
+                GL11.glRotatef((float)headPitch, 1f, 0f, 0f);
+                GL11.glRotatef((float)headYaw, 0f, 1f, 0f);
+
+                // Position adjust
+                GL11.glTranslatef(camRelX, camRelY, camRelZ);
+
+                // Rotate HUD to appropriate position
+                GL11.glRotatef(this.mc.vrSettings.hudPitchOffset - guiPitch, 1f, 0f, 0f);
+                GL11.glRotatef(guiYaw - lookYawOffset - this.mc.vrSettings.hudYawOffset, 0f, 1f, 0f);
+
+                // Move out HUD distance
+                GL11.glTranslatef(0.0f, 0.0f, -this.mc.vrSettings.hudDistance);
+            }
+
+            if (this.mc.theWorld != null)
+            {
+                GL11.glEnable(GL11.GL_BLEND);
+                GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+                GL11.glColor4f(1, 1, 1, this.mc.vrSettings.hudOpacity);
+            }
+            else
+                GL11.glColor4f(1, 1, 1, 1);
+
+            if (!this.mc.vrSettings.hudOcclusion)
+                GL11.glDisable(GL11.GL_DEPTH_TEST);
+
+            drawSizedQuad(this.mc.displayFBWidth, this.mc.displayFBHeight, this.mc.vrSettings.hudScale);
+
+            GL11.glDisable(GL11.GL_BLEND);
+            GL11.glEnable(GL11.GL_DEPTH_TEST);
+            GL11.glEnable(GL11.GL_CULL_FACE);
+
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPopMatrix();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPopMatrix();
+
+            this.mc.guiFramebuffer.unbindFramebufferTexture();
+            //mc.checkGLError("GUI");
+        }
+
+        displayCalibrationText();
+	}
+
+    public void renderVrGui(float renderPartialTicks)
+    {
+        this.guiShowingThisFrame = false;
+
+        int currentDisplayWidth = this.mc.displayWidth;
+        int currentDisplayHeight = this.mc.displayHeight;
+
+        // Hack the GUI w & h
+        this.mc.displayWidth = this.mc.displayFBWidth;
+        this.mc.displayHeight = this.mc.displayFBHeight;
+
+        int mouseX = 0;
+        int mouseY = 0;
+        final ScaledResolution var15 = new ScaledResolution(this.mc, this.mc.displayFBWidth, this.mc.displayFBHeight);
+        int var16 = var15.getScaledWidth();
+        int var17 = var15.getScaledHeight();
+
+        //this.mc.loadingScreen.field_146588_g = this.mc.guiFramebuffer;
+
+        if (this.mc.isIntegratedServerLaunching())
+        {
+            //this.guiShowingThisFrame = true;   // TODO: REENABLE
+            this.mc.displayWidth = currentDisplayWidth;
+            this.mc.displayHeight = currentDisplayHeight;
+            return;
+        }
+
+        if (this.mc.renderStereo)
+        {
+            this.mc.guiFramebuffer.bindFramebuffer(true);
+
+            if ((this.mc.theWorld != null && !this.mc.gameSettings.hideGUI && this.mc.thePlayer.getSleepTimer() == 0) || this.mc.currentScreen != null)
+            {
+                //Render all UI elements into guiFBO
+                mouseX = (int)Math.ceil((float)Mouse.getX() / (float)((float)this.mc.displayFBWidth / (float)var16));
+                mouseY = (int)Math.ceil((float)var17 - ((float)Mouse.getY() / (float)((float)this.mc.displayFBHeight / (float)var17)));
+
+                GL11.glClearColor(0, 0, 0, 0);
+                GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+                GL11.glMatrixMode(GL11.GL_PROJECTION);
+                GL11.glLoadIdentity();
+                GL11.glOrtho(0.0D, var15.getScaledWidth_double(), var15.getScaledHeight_double(), 0.0D, 1000.0D, 3000.0D);
+                GL11.glMatrixMode(GL11.GL_MODELVIEW);
+                GL11.glLoadIdentity();
+                GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
+                this.guiShowingThisFrame = true;
+            }
+
+            if (this.guiShowingThisFrame)
+            {
+                // Display loading / progress window if necessary
+                if (this.mc.theWorld != null && !this.mc.gameSettings.hideGUI /*&& !this.blankGUIUntilWorldValid*/)
+                {
+                    // Disable any forge gui crosshairs and helmet overlay (pumkinblur)
+                    if (Reflector.ForgeGuiIngame_renderCrosshairs.exists()) {
+                        Reflector.ForgeGuiIngame_renderCrosshairs.setValue(false);
+                        Reflector.ForgeGuiIngame_renderHelmet.setValue(false);
+                    }
+                    //Draw in game GUI
+                    GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+                    this.mc.ingameGUI.renderGameOverlay(renderPartialTicks, this.mc.currentScreen != null, mouseX, mouseY);
+                    mc.guiAchievement.func_146254_a();
+                    GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
+                }
+
+//        if (this.blankGUIUntilWorldValid) {
+//            if (this.mc.theWorld != null)
+//                this.blankGUIUntilWorldValid = false;
+//        }
+
+                if (this.mc.currentScreen != null /*&& !this.blankGUIUntilWorldValid*/) {
+                    //GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
+
+                    final int mouseX1 = mouseX;
+                    final int mouseY1 = mouseY;
+
+                    try
+                    {
+                        boolean drawScreenHandled = false;
+                        if (Reflector.EventBus_post.exists())
+                        {
+                            drawScreenHandled = Reflector.postForgeBusEvent(Reflector.DrawScreenEvent_Pre_Constructor, new Object[] {this.mc.currentScreen, Integer.valueOf(mouseX), Integer.valueOf(mouseY), Float.valueOf(renderPartialTicks)});
+                        }
+
+                        if (!drawScreenHandled)
+                        {
+                            this.mc.currentScreen.drawScreen(mouseX, mouseY, renderPartialTicks);
+                        }
+
+                        Reflector.postForgeBusEvent(Reflector.DrawScreenEvent_Post_Constructor, new Object[] {this.mc.currentScreen, Integer.valueOf(mouseX), Integer.valueOf(mouseY), Float.valueOf(renderPartialTicks)});
+                    }
+                    catch (Throwable throwable)
+                    {
+                        CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Rendering screen");
+                        CrashReportCategory crashreportcategory = crashreport.makeCategory("Screen render details");
+                        crashreportcategory.addCrashSectionCallable("Screen name", new Callable() {
+                            private static final String __OBFID = "CL_00000948";
+
+                            public String call() {
+                                return Minecraft.getMinecraft().currentScreen.getClass().getCanonicalName();
+                            }
+                        });
+                        crashreportcategory.addCrashSectionCallable("Mouse location", new Callable() {
+                            private static final String __OBFID = "CL_00000950";
+
+                            public String call() {
+                                return String.format("Scaled: (%d, %d). Absolute: (%d, %d)", new Object[]{Integer.valueOf(mouseX1), Integer.valueOf(mouseY1), Integer.valueOf(Mouse.getX()), Integer.valueOf(Mouse.getY())});
+                            }
+                        });
+                        crashreportcategory.addCrashSectionCallable("Screen size", new Callable() {
+                            private static final String __OBFID = "CL_00000951";
+
+                            public String call() {
+                                return String.format("Scaled: (%d, %d). Absolute: (%d, %d). Scale factor of %d", new Object[]{Integer.valueOf(var15.getScaledWidth()), Integer.valueOf(var15.getScaledHeight()), Integer.valueOf(Minecraft.getMinecraft().displayWidth), Integer.valueOf(Minecraft.getMinecraft().displayHeight), Integer.valueOf(var15.getScaleFactor())});
+                            }
+                        });
+                        throw new ReportedException(crashreport);
+                    }
+
+                    GL11.glDisable(GL11.GL_LIGHTING); //inventory messes up fog color sometimes... This fixes
+                    GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+                    drawMouseMenuQuad(mouseX, mouseY);
+                }
+
+                this.mc.guiFramebuffer.bindFramebufferTexture();
+                this.mc.guiFramebuffer.genMipMaps();
+                this.mc.guiFramebuffer.unbindFramebufferTexture();
+            }
+        }
+
+        this.mc.displayWidth = currentDisplayWidth;
+        this.mc.displayHeight = currentDisplayHeight;
+    }
+
+    public void drawMouseMenuQuad(int mouseX, int mouseY)
+    {
+        GL11.glDisable(GL11.GL_BLEND);
+        GL11.glDisable(GL11.GL_DEPTH_TEST);
+        GL11.glColor3f(1, 1, 1);
+        this.mc.mcProfiler.endStartSection("mouse pointer");
+        this.mc.getTextureManager().bindTexture(Gui.icons);
+        float menuMousePointerSize = 16f * this.mc.vrSettings.menuCrosshairScale;
+        this.mc.ingameGUI.drawCentredTexturedModalRect(mouseX, mouseY, menuMousePointerSize, menuMousePointerSize, 0, 0, 15, 15);
+
+        GL11.glEnable(GL11.GL_BLEND);
+    }
 
     public void func_152430_c(float p_152430_1_)
     {
@@ -1435,9 +1935,23 @@
         EntityLivingBase var4 = this.mc.renderViewEntity;
         RenderGlobal var5 = this.mc.renderGlobal;
         EffectRenderer var6 = this.mc.effectRenderer;
-        double var7 = var4.lastTickPosX + (var4.posX - var4.lastTickPosX) * (double)par1;
-        double var9 = var4.lastTickPosY + (var4.posY - var4.lastTickPosY) * (double)par1;
-        double var11 = var4.lastTickPosZ + (var4.posZ - var4.lastTickPosZ) * (double)par1;
+        /** Minecrift */
+        renderOriginX = var4.lastTickPosX + (var4.posX - var4.lastTickPosX) * (double)par1;
+        renderOriginY = var4.lastTickPosY + (var4.posY - var4.lastTickPosY) * (double)par1;
+        renderOriginZ = var4.lastTickPosZ + (var4.posZ - var4.lastTickPosZ) * (double)par1;
+        renderOrigin = Vec3.createVectorHelper(renderOriginX, renderOriginY, renderOriginZ);
+
+        if( this.mc.currentScreen == null )
+        {
+            this.mc.mcProfiler.endStartSection("pick");
+            getPointedBlock(par1);   // TODO: This needs to be called once, and with the average position
+                                     // information for the entire frame, not individual eye pos camRelX, Y, Z
+        }
+
+        // Update sound engine
+        setSoundListenerOrientation();
+        /* end Minecrift */
+
         this.mc.mcProfiler.endStartSection("center");
 
         for (int var13 = 0; var13 < 2; ++var13)
@@ -1463,6 +1977,13 @@
             GL11.glEnable(GL11.GL_CULL_FACE);
             this.mc.mcProfiler.endStartSection("camera");
             this.setupCameraTransform(par1, var13);
+
+            // Minecrift - save our projection and modelview matrices
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPushMatrix();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPushMatrix();
+
             ActiveRenderInfo.updateRenderInfo(this.mc.thePlayer, this.mc.gameSettings.thirdPersonView == 2);
             this.mc.mcProfiler.endStartSection("frustrum");
             ClippingHelperImpl.getInstance();
@@ -1488,10 +2009,10 @@
 
             this.mc.mcProfiler.endStartSection("culling");
             Frustrum var14 = new Frustrum();
-            var14.setPosition(var7, var9, var11);
+            var14.setPosition(renderOriginX, renderOriginY, renderOriginZ);
             this.mc.renderGlobal.clipRenderersByFrustum(var14, par1);
 
-            if (var13 == 0)
+            if (var13 == 0 && renderpass == 0)  /** Minecrift **/
             {
                 this.mc.mcProfiler.endStartSection("updatechunks");
 
@@ -1525,6 +2046,13 @@
             boolean hasForge = Reflector.ForgeHooksClient.exists();
             EntityPlayer var18;
 
+            // Minecrift
+            boolean renderOutline = this.mc.vrSettings.renderBlockOutlineMode == VRSettings.RENDER_BLOCK_OUTLINE_MODE_ALWAYS ||
+                    (this.mc.vrSettings.renderBlockOutlineMode == VRSettings.RENDER_BLOCK_OUTLINE_MODE_HUD && !this.mc.gameSettings.hideGUI);
+
+            // Minecrift - crosshair rendering
+            renderCrosshairAtDepth();
+
             if (this.debugViewDirection == 0)
             {
                 GL11.glMatrixMode(GL11.GL_MODELVIEW);
@@ -1551,13 +2079,13 @@
                 GL11.glPopMatrix();
                 GL11.glPushMatrix();
 
-                if (this.mc.objectMouseOver != null && var4.isInsideOfMaterial(Material.water) && var4 instanceof EntityPlayer && !this.mc.gameSettings.hideGUI)
+                if (this.mc.objectMouseOver != null && var4.isInsideOfMaterial(Material.water) && var4 instanceof EntityPlayer && renderOutline)     // Minecrift
                 {
                     var18 = (EntityPlayer)var4;
                     GL11.glDisable(GL11.GL_ALPHA_TEST);
                     this.mc.mcProfiler.endStartSection("outline");
 
-                    if ((!hasForge || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {var5, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(par1)})) && !this.mc.gameSettings.hideGUI)
+                    if ((!hasForge || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {var5, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(par1)})) && renderOutline)    // Minecrift
                     {
                         var5.drawSelectionBox(var18, this.mc.objectMouseOver, 0, par1);
                     }
@@ -1568,13 +2096,13 @@
             GL11.glMatrixMode(GL11.GL_MODELVIEW);
             GL11.glPopMatrix();
 
-            if (this.cameraZoom == 1.0D && var4 instanceof EntityPlayer && !this.mc.gameSettings.hideGUI && this.mc.objectMouseOver != null && !var4.isInsideOfMaterial(Material.water))
+            if (this.cameraZoom == 1.0D && var4 instanceof EntityPlayer && renderOutline && this.mc.objectMouseOver != null && !var4.isInsideOfMaterial(Material.water))   // Minecrift
             {
                 var18 = (EntityPlayer)var4;
                 GL11.glDisable(GL11.GL_ALPHA_TEST);
                 this.mc.mcProfiler.endStartSection("outline");
 
-                if ((!hasForge || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {var5, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(par1)})) && !this.mc.gameSettings.hideGUI)
+                if ((!hasForge || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {var5, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(par1)})) && renderOutline)    // Minecrift
                 {
                     var5.drawSelectionBox(var18, this.mc.objectMouseOver, 0, par1);
                 }
@@ -1682,13 +2210,20 @@
                 Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, new Object[] {var5, Float.valueOf(par1)});
             }
 
+            // Minecrift - restore our projection and modelview matrices
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPopMatrix();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPopMatrix();
+
             this.mc.mcProfiler.endStartSection("hand");
             boolean renderFirstPersonHand = Reflector.callBoolean(Reflector.ForgeHooksClient_renderFirstPersonHand, new Object[] {this.mc.renderGlobal, Float.valueOf(par1), Integer.valueOf(var13)});
 
             if (!renderFirstPersonHand && this.cameraZoom == 1.0D)
             {
-                GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
-                this.renderHand(par1, var13);
+                //GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);     // If we disable this, the GUI occlusion
+                                                            // seems to work but the depth seems all wrong. What's up there? Answer: Need same projection matrix!
+                //this.renderHand(par1, var13);
             }
 
             if (!this.mc.gameSettings.anaglyph)
@@ -1702,6 +2237,66 @@
         this.mc.mcProfiler.endSection();
     }
 
+    /** Minecrift **/
+    public void renderCrosshairAtDepth()
+    {
+        if (this.aimStartPos != null)
+        {
+            Vec3 originOffset = renderOrigin.subtract(this.aimRenderOrigin);
+            Vec3 start = this.aimStartPos.addVector(originOffset.xCoord, originOffset.yCoord, originOffset.zCoord);
+            Vec3 end = this.aimEndPos.addVector(originOffset.xCoord, originOffset.yCoord, originOffset.zCoord);
+            drawLine(start, end);
+        }
+
+        //Draw crosshair
+        boolean renderCrosshair = this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_ALWAYS ||
+                (this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_HUD && !this.mc.gameSettings.hideGUI);
+
+        if( this.mc.currentScreen == null && this.mc.gameSettings.thirdPersonView == 0 && renderCrosshair)
+        {
+            this.mc.mcProfiler.endStartSection("crosshair");
+            GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f); //white crosshair, with blending
+            float crossDepth = (float)Math.sqrt((crossX*crossX + crossY*crossY + crossZ*crossZ));
+            float scale = 0.025f*crossDepth*this.mc.vrSettings.crosshairScale;
+
+            GL11.glPushMatrix();
+            GL11.glTranslatef(crossX, crossY, crossZ);
+            GL11.glRotatef(-this.aimYaw, 0.0F, 1.0F, 0.0F);
+            GL11.glRotatef(this.aimPitch, 1.0F, 0.0F, 0.0F);
+            if (this.mc.vrSettings.crosshairRollsWithHead)
+                GL11.glRotated(this.cameraRoll, 0.0F, 0.0F, 1.0F);
+            GL11.glScalef(-scale, -scale, scale);
+            GL11.glDisable(GL11.GL_LIGHTING);
+            if (!this.mc.vrSettings.useCrosshairOcclusion)
+                GL11.glDisable(GL11.GL_DEPTH_TEST);
+            GL11.glEnable(GL11.GL_BLEND);
+            GL11.glBlendFunc(GL11.GL_ONE_MINUS_DST_COLOR, GL11.GL_ONE_MINUS_SRC_COLOR);
+            this.mc.getTextureManager().bindTexture(Gui.icons);
+
+            if (!generatedIconMipmaps[this.mc.currentEye.value()])
+                this.mc.getFramebuffer().genMipMaps();
+
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST_MIPMAP_LINEAR);
+            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+
+            float var7 = 0.00390625F;
+            float var8 = 0.00390625F;
+            Tessellator.instance.startDrawingQuads();
+            Tessellator.instance.addVertexWithUV(- 1, + 1, 0,  0     , 15* var8);
+            Tessellator.instance.addVertexWithUV(+ 1, + 1, 0, 15*var7, 15* var8);
+            Tessellator.instance.addVertexWithUV(+ 1, - 1, 0, 15*var7, 0       );
+            Tessellator.instance.addVertexWithUV(- 1, - 1, 0, 0      , 0       );
+            Tessellator.instance.draw();
+            GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+            GL11.glDisable(GL11.GL_BLEND);
+            GL11.glEnable(GL11.GL_DEPTH_TEST);
+            GL11.glPopMatrix();
+            //mc.checkGLError("crosshair");
+        }
+    }
+
     /**
      * Render clouds if enabled
      */
@@ -2593,4 +3188,551 @@
             ;
         }
     }
+
+	/** Minecrift additions **/
+    public void updatePositionAndOrientation( float renderPartialTicks, boolean displayActive )
+    {
+        //int millis = (int)(System.currentTimeMillis() - start);
+        //System.out.println("Update camera! " + millis + "ms");
+
+        float PIOVER180 = (float)(Math.PI/180);
+        EntityLivingBase entity = this.mc.renderViewEntity;
+
+        //runs a step of calibration
+        if(calibrationHelper != null && calibrationHelper.allPluginsCalibrated())
+        {
+            calibrationHelper = null;
+        }
+
+        if (this.mc.vrSettings.posTrackResetPosition)
+        {
+            //mc.positionTracker.resetOrigin(); // TODO: HACK - Ensure we don't call reset in quick succession with the Oculus...
+                                                // this needs a cool down timer or something until the next reset on the same
+                                                // device is allowed
+            mc.headTracker.resetOrigin();
+            guiYawOrientationResetRequested = true;
+            this.mc.vrSettings.posTrackResetPosition = false;
+        }
+
+        // TODO: PollAll can call controller code that updates the GUI.
+        // All controller code should be moved to UpdateTick really. For
+        // now, hack the displaySize so that any gui screens changed use
+        // the correct size...
+        int currentDisplayWidth = this.mc.displayWidth;
+        int currentDisplayHeight = this.mc.displayHeight;
+        this.mc.displayWidth = this.mc.displayFBWidth;
+        this.mc.displayHeight = this.mc.displayFBHeight;
+
+        // Poll sensors
+        PluginManager.pollAll();
+
+        this.mc.displayWidth = currentDisplayWidth;
+        this.mc.displayHeight = currentDisplayHeight;
+        // TODO: End display size hack
+
+        if(JoystickAim.selectedJoystickMode != null)
+            JoystickAim.selectedJoystickMode.update( renderPartialTicks );
+
+        lookYawOffset   = mc.lookaimController.getBodyYawDegrees();
+        lookPitchOffset = mc.lookaimController.getBodyPitchDegrees();
+
+        if (mc.headTracker.isInitialized() && this.mc.vrSettings.useHeadTracking)
+        {
+            this.mc.mcProfiler.startSection("oculus");
+
+            prevHeadYaw   = headYaw;
+            prevHeadPitch = headPitch;
+            prevHeadRoll  = headRoll;
+
+            // Get 'raw' tracker orientation
+            Quaternion orientation = new Quaternion(this.mc.currentPose.Orientation.x,
+                                                    this.mc.currentPose.Orientation.y,
+                                                    this.mc.currentPose.Orientation.z,
+                                                    this.mc.currentPose.Orientation.w);
+
+            currentEulerOrientDegrees = OculusRift.getEulerAnglesDeg(this.mc.currentPose.Orientation,
+                1.0f,
+                Axis.Axis_Y,
+                Axis.Axis_X,
+                Axis.Axis_Z,
+                HandedSystem.Handed_L,
+                RotateDirection.Rotate_CCW);
+//
+//            this.mc.thePlayer.rotationYaw = currentEulerOrientDegrees.yaw;
+//            this.mc.thePlayer.rotationPitch = currentEulerOrientDegrees.pitch;
+
+            Quaternion orient = new Quaternion(this.mc.currentPose.Orientation.x,
+                                               this.mc.currentPose.Orientation.y,
+                                               this.mc.currentPose.Orientation.z,
+                                               this.mc.currentPose.Orientation.w);
+
+            headYaw    = currentEulerOrientDegrees.yaw;
+            headPitch  = currentEulerOrientDegrees.pitch;
+            headRoll   = currentEulerOrientDegrees.roll;
+
+            // Pitch offset
+            Quaternion pitchCorrection = new Quaternion();
+            Vector4f vecAxisPitchAngle = new Vector4f(1f, 0f, 0f, -lookPitchOffset * PIOVER180);
+            pitchCorrection.setFromAxisAngle(vecAxisPitchAngle);
+
+            // Yaw offset
+            Quaternion yawCorrection   = new Quaternion();
+            Vector4f vecAxisYawAngle   = new Vector4f(0f, 1f, 0f, (-lookYawOffset * PIOVER180));
+            yawCorrection.setFromAxisAngle(vecAxisYawAngle);
+
+            Quaternion correctedOrient = QuaternionHelper.mul(yawCorrection,   QuaternionHelper.mul(pitchCorrection, orient));
+            Quatf corOrient = new Quatf(correctedOrient.x,
+                    correctedOrient.y,
+                    correctedOrient.z,
+                    correctedOrient.w);
+
+            // Euler
+            EulerOrient correctedEulerOrientDegrees = OculusRift.getEulerAnglesDeg(corOrient,
+                    1.0f,
+                    Axis.Axis_Y,
+                    Axis.Axis_X,
+                    Axis.Axis_Z,
+                    HandedSystem.Handed_L,
+                    RotateDirection.Rotate_CCW);
+
+            cameraYaw    = correctedEulerOrientDegrees.yaw;
+            cameraPitch  = correctedEulerOrientDegrees.pitch;
+            cameraRoll   = correctedEulerOrientDegrees.roll;
+
+            if (this.mc.vrSettings.debugPose)
+            {
+                System.out.println(String.format("headYaw:   %.2f, headPitch:   %.2f, headRoll:   %.2f", new Object[] {Float.valueOf(headYaw), Float.valueOf(headPitch), Float.valueOf(headRoll)}));
+                System.out.println(String.format("cameraYaw: %.2f, cameraPitch: %.2f, cameraRoll: %.2f", new Object[] {Float.valueOf((float)cameraYaw), Float.valueOf((float)cameraPitch), Float.valueOf((float)cameraRoll)}));
+            }
+
+            this.mc.mcProfiler.endSection();
+        }
+        else
+        {
+            cameraRoll = 0;
+            cameraPitch = lookPitchOffset;
+            cameraYaw = lookYawOffset;
+        }
+
+        if( entity != null )
+        {
+            //set movement direction
+            if( this.mc.vrSettings.lookMoveDecoupled )
+                entity.rotationYaw = lookYawOffset;
+            else
+                entity.rotationYaw = (float)cameraYaw;
+            entity.rotationYawHead = (float)cameraYaw;
+            entity.rotationPitch = (float)cameraPitch;
+
+        }
+
+        if( this.mc.vrSettings.aimKeyholeWidthDegrees > 0 )
+            aimYaw    = mc.lookaimController.getAimYaw();
+        else
+            aimYaw = (float)cameraYaw;
+
+        if( this.mc.vrSettings.keyholeHeight > 0 )
+            aimPitch  = mc.lookaimController.getAimPitch();
+        else
+            aimPitch = (float)cameraPitch;
+
+        aimPitch -= this.mc.vrSettings.aimPitchOffset;
+
+
+        //TODO: not sure if headPitch or cameraPitch is better here... they really should be the same; silly
+        //people with their "pitch affects camera" settings.
+        //At any rate, using cameraPitch makes the UI look less silly
+        mc.positionTracker.update(this.mc.vrSettings.getHalfIPD(this.mc.currentEye), headYaw, (float)headPitch, (float)headRoll, lookYawOffset, 0.0f, 0.0f);
+
+        //Do head/neck model in non-GL math so we can use camera location(between eyes)
+        Vec3 cameraOffset = mc.positionTracker.getEyePosition(this.mc.currentEye);
+        cameraOffset.rotateAroundY((float)Math.PI);
+
+        //The worldOrigin is at player "eye height" (1.62) above foot position
+        camRelX = (float)cameraOffset.xCoord; camRelY = (float)cameraOffset.yCoord; camRelZ = (float)cameraOffset.zCoord;
+
+        if (this.mc.vrSettings.debugPose)
+        {
+            System.out.println(String.format("camRelX:    %.2f, camRelY:    %.2f, camRelZ:    %.2f", new Object[] {Float.valueOf(camRelX), Float.valueOf(camRelY), Float.valueOf(camRelZ)}));
+        }
+
+        headCollision = false;
+        headCollisionDistance = -1;
+
+        if(this.mc.theWorld != null && this.mc.gameSettings.thirdPersonView == 0)
+        {
+            Vec3 eyeCentrePos = getEyeCentrePosInWorldFrame();
+            eyeCentrePos.rotateAroundY((float)Math.PI);
+            float eyeDistFromOrigin = (float)eyeCentrePos.lengthVector();
+            eyeCentrePos.yCoord = -eyeCentrePos.yCoord; // TODO: y negation
+
+            // TODO: This is all a bit broken at the moment...
+            //float cameraYOffset = -this.mc.vrSettings.getPlayerEyeHeight() + 1.62f;
+            float collDistFromOrigin = checkCameraCollision(renderOriginX, renderOriginY /*- cameraYOffset*/, renderOriginZ,
+                    eyeCentrePos.xCoord, eyeCentrePos.yCoord, eyeCentrePos.zCoord, eyeDistFromOrigin );
+
+            if (eyeDistFromOrigin < 0.02f)    // Hack for if eyeDist is too small, no decent length raytrace
+                                              // occurs meaning we flag up a collision when there isn't one.
+            {
+                headCollision = false;
+                headCollisionDistance = -1;
+            }
+            else if( collDistFromOrigin < eyeDistFromOrigin )
+            {
+                // Prevent clipping if not blanking screen
+                if (!this.mc.vrSettings.posTrackBlankOnCollision)
+                {
+                    float scale = collDistFromOrigin / eyeDistFromOrigin;    // #47 Removed additional scale factor
+                    camRelX *= scale;
+                    camRelY *= scale;
+                    camRelZ *= scale;
+                }
+
+                headCollision = true;
+                headCollisionDistance = 0f;
+            }
+            else
+            {
+                headCollision = false;
+                headCollisionDistance = collDistFromOrigin - eyeDistFromOrigin;
+            }
+        }
+
+        Vec3 look = Vec3.createVectorHelper(0, 0, 1);
+        look.rotateAroundX(-(float)cameraPitch* PIOVER180);
+        look.rotateAroundY(-(float)cameraYaw  * PIOVER180);
+        lookX = (float)look.xCoord; lookY = (float)look.yCoord; lookZ = (float)look.zCoord;
+
+        Vec3 aim = Vec3.createVectorHelper(0, 0, 1);
+        aim.rotateAroundX(-aimPitch * PIOVER180);
+        aim.rotateAroundY(-aimYaw   * PIOVER180);
+        aimX = (float)aim.xCoord; aimY = (float)aim.yCoord; aimZ = (float)aim.zCoord;
+
+        if(guiYawOrientationResetRequested)
+        {
+            //Hit once at startup and if reset requested (usually during calibration when an origin
+            //has been set)
+            guiHeadYaw = 0f;
+            guiYawOrientationResetRequested = false;
+            guiShowingLastFrame = false;
+        }
+    }
+
+    private float checkCameraCollision(
+            double camX,       double camY,       double camZ,
+            double camXOffset, double camYOffset, double camZOffset, float distance )
+    {
+        //This loop offsets at [-.1, -.1, -.1], [.1,-.1,-.1], [.1,.1,-.1] etc... for all 8 directions
+        double minDistance = -1d;
+
+        // Lets extend out the test range somewhat
+        camXOffset *= 10f;
+        camYOffset *= 10f;
+        camZOffset *= 10f;
+
+        for (int var20 = 0; var20 < 8; ++var20)
+        {
+            final float MIN_DISTANCE = 0.06F;
+            float var21 = (float)((var20 & 1) * 2 - 1);
+            float var22 = (float)((var20 >> 1 & 1) * 2 - 1);
+            float var23 = (float)((var20 >> 2 & 1) * 2 - 1);
+            var21 *= 0.1F;
+            var22 *= 0.1F;
+            var23 *= 0.1F;
+            MovingObjectPosition var24 = this.mc.theWorld.rayTraceBlocks(
+                    Vec3.createVectorHelper(camX + var21, camY + var22, camZ + var23),
+                    Vec3.createVectorHelper(camX - camXOffset + var21, camY - camYOffset + var22, camZ - camZOffset + var23));
+
+            if (var24 != null && this.mc.theWorld.isBlockNormalCubeDefault(var24.blockX, var24.blockY, var24.blockZ, true))
+            {
+                double var25 = var24.hitVec.distanceTo(Vec3.createVectorHelper(camX, camY, camZ)) - MIN_DISTANCE;
+
+                if (minDistance == -1d)
+                {
+                    minDistance = var25;
+                }
+                else if (var25 < minDistance)
+                {
+                    minDistance = var25;
+                }
+            }
+        }
+        if (minDistance == -1d)
+            minDistance = distance *= 10d;
+
+        return (float)minDistance;
+    }
+
+    public void drawSizedQuad(float displayWidth, float displayHeight, float size)
+    {
+        float aspect = displayHeight / displayWidth;
+
+        GL11.glBegin(GL11.GL_QUADS);
+
+        GL11.glTexCoord2f(0.0f, 0.0f);
+        GL11.glVertex3f(-(size / 2f), -(size * aspect) / 2f, 0.0f);  // Bottom Left Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 0.0f);
+        GL11.glVertex3f(size / 2f, -(size * aspect) / 2f, 0.0f);  // Bottom Right Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 1.0f);
+        GL11.glVertex3f(size / 2f, (size * aspect) / 2f, 0.0f);  // Top Right Of The Texture and Quad
+        GL11.glTexCoord2f(0.0f, 1.0f);
+        GL11.glVertex3f(-(size / 2f), (size * aspect) / 2f, 0.0f);  // Top Left  Of The Texture and Quad
+
+        GL11.glEnd();
+    }
+
+    // TODO: Move this into Reflector OR use existing Reflector function!
+    public Field getDeclaredField(Class clazz, String unObfuscatedName, String obfuscatedName)
+    {
+        Field field = null;
+        String s = clazz.getName();
+
+        try
+        {
+            field = clazz.getDeclaredField(unObfuscatedName);
+        }
+        catch (NoSuchFieldException e)
+        {
+            e.printStackTrace();
+
+            try
+            {
+                field = clazz.getDeclaredField(obfuscatedName);
+            }
+            catch (NoSuchFieldException e1)
+            {
+                e1.printStackTrace();
+            };
+        }
+
+        return field;
+    }
+
+    /**
+     * Sets the listener of sounds
+     */
+    public void setSoundListenerOrientation()
+    {
+        SoundSystem sndSystem = null;
+
+        // Get the soundManager from mc.mcSoundHandler (field_147694_f)
+        // then get SoundSystem from it (field_148620_e)
+        // Obfuscated names (from MCP908/conf/joined.srg):
+        //    SoundHandler.field_147694_f = btp/a
+        //    SoundSystem.field_148620_e = btj/e
+
+        // Use reflection to get the sndManager
+        if (sndSystemReflect && _soundManagerSndSystemField == null && this.trySoundSystemReflect)
+        {
+            try
+            {
+                // Get SoundManager from the SoundHandler...
+                Field soundManagerField = getDeclaredField(mc.mcSoundHandler.getClass(), "field_147694_f", "f");
+                if (soundManagerField != null)
+                {
+                    soundManagerField.setAccessible(true);
+                    this.mc.sndManager = (SoundManager) soundManagerField.get(mc.mcSoundHandler);
+                }
+
+                // ...get SoundSystem from SoundManager
+                if (this.mc.sndManager != null)
+                {
+                    _soundManagerSndSystemField = getDeclaredField(this.mc.sndManager.getClass(), "field_148620_e", "e");
+                    if (_soundManagerSndSystemField != null)
+                    {
+                        _soundManagerSndSystemField.setAccessible(true);
+                        System.out.println("[Minecrift]: Reflected sndSystem");
+                    }
+                }
+            }
+            catch (IllegalAccessException e)
+            {
+                e.printStackTrace();
+            }
+
+            if (_soundManagerSndSystemField == null) {
+                this.trySoundSystemReflect = false;
+                System.out.println("[Minecrift]: FAILED to reflect sndSystem");
+            }
+        }
+
+        if (_soundManagerSndSystemField != null && this.mc.sndManager != null)
+        {
+            try
+            {
+                sndSystem = (SoundSystem)_soundManagerSndSystemField.get(this.mc.sndManager);
+            }
+            catch (IllegalArgumentException e) { }
+            catch (IllegalAccessException e) { };
+        }
+
+        float PIOVER180 = (float)(Math.PI/180);
+
+        // TODO: Set based on head orient (headphones) or body orient (speakers)
+
+        Vec3 up = Vec3.createVectorHelper(0, 1, 0);
+        up.rotateAroundZ(-(float)cameraRoll * PIOVER180);
+        up.rotateAroundX(-(float)cameraPitch* PIOVER180);
+        up.rotateAroundY(-(float)cameraYaw  * PIOVER180);
+        //synchronized (SoundSystemConfig.THREAD_SYNC) {
+            if (/*SoundManger.soundLibrary != null &&*/ sndSystem != null /* && this.mc.gameSettings.getSoundVolume(SoundCategory // Which sound category?) != 0f // this.mc.gameSettings.soundVolume != 0f */)
+            {
+                // The sound system is on a separate thread? Sync issues? Can get to crash by turning analyglph mode on?
+
+                sndSystem.setListenerPosition((float) renderOriginX, (float) renderOriginY, (float) renderOriginZ);
+
+                sndSystem.setListenerOrientation(lookX, lookY, lookZ,
+                        (float) up.xCoord, (float) up.yCoord, (float) up.zCoord);
+            }
+        //}
+        if( mc.mumbleLink != null ) {
+            Vec3 forward = Vec3.createVectorHelper(0, 0 , -1);
+            forward.rotateAroundZ(-(float)cameraRoll * PIOVER180);
+            forward.rotateAroundX(-(float)cameraPitch* PIOVER180);
+            forward.rotateAroundY(-(float)cameraYaw  * PIOVER180);
+            mc.mumbleLink.updateMumble(
+                    (float)renderOriginX,  (float)renderOriginY,  (float)renderOriginZ,
+                    (float)forward.xCoord, (float)forward.yCoord, (float)forward.zCoord,
+                    (float)up.xCoord,      (float)up.yCoord,      (float)up.zCoord);
+        }
+    }
+
+    public void startCalibration()
+    {
+        calibrationHelper = new CalibrationHelper(mc);
+    }
+
+    public void displayCalibrationText()
+    {
+        if (calibrationHelper != null)
+        {
+            // Pass matrici on to OpenGL...
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPushMatrix();
+            GL11.glLoadIdentity();
+            GL11.glMultMatrix(eyeproj[this.mc.currentEye.value()].transposed().toFloatBuffer());     // Needs eyeProj to have been setup previously
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPushMatrix();
+            GL11.glLoadIdentity();
+
+            float x = -this.mc.vrSettings.getHalfIPD(this.mc.currentEye) * this.mc.vrSettings.ipdScale;///*lookX */ (-mc.vrSettings.hudDistance * 0.9f);
+            float y = 0f;//*lookY */ (-mc.vrSettings.hudDistance * 0.9f);
+            float z = /*lookZ */ (-mc.vrSettings.hudDistance * 0.9f);
+
+            GL11.glDisable(GL11.GL_DEPTH_TEST);
+            GL11.glTranslatef(x, y, z);
+            GL11.glRotated(/*this.cameraYaw +*/ 180f, 0.0F, 1.0F, 0.0F);
+//            GL11.glRotated(this.cameraPitch, 1.0F, 0.0F, 0.0F);
+//            GL11.glRotated(this.cameraRoll, 0.0F, 0.0F, 1.0F);
+            float textScale = (float) Math.sqrt((x * x + y * y + z * z));
+            GL11.glScalef(-INITIAL_CALIBRATION_TEXT_SCALE * textScale, -INITIAL_CALIBRATION_TEXT_SCALE * textScale, -INITIAL_CALIBRATION_TEXT_SCALE * textScale);
+            String calibrating = "Calibrating " + calibrationHelper.currentPlugin.getName() + "...";
+            mc.fontRenderer.drawStringWithShadow(calibrating, -mc.fontRenderer.getStringWidth(calibrating) / 2, -8, /*white*/16777215);
+            String calibrationStep = calibrationHelper.calibrationStep;
+//                mc.fontRenderer.drawStringWithShadow(calibrationStep, -mc.fontRenderer.getStringWidth(calibrationStep)/2, 8, /*white*/16777215);
+
+            int column = 8;
+            ArrayList<String> wrapped = new ArrayList<String>();
+            Utils.wordWrap(calibrationStep, CALIBRATION_TEXT_WORDWRAP_LEN, wrapped);
+            for (String line : wrapped)
+            {
+                mc.fontRenderer.drawStringWithShadow(line, -mc.fontRenderer.getStringWidth(line) / 2, column, /*white*/16777215);
+                column += 16;
+            }
+
+            GL11.glEnable(GL11.GL_DEPTH_TEST);
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPopMatrix();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPopMatrix();
+        }
+    }
+
+    public void renderPositionalTrackFade()
+    {
+         if (this.mc.theWorld != null && this.mc.vrSettings.posTrackBlankOnCollision == true)
+         {
+             Color3f rgb = new Color3f(0f, 0f, 0f);
+             //Color3f rgb = new Color3f(255f, 0f, 0f);
+             //Color3f rgb = new Color3f(255f, 255f, 255f);
+
+             if (this.headCollision)
+             {
+                 renderFadeBlend(rgb, 1f);
+                 //this.mc.printChatMessage("Collision");
+             }
+             else if (this.headCollisionDistance != -1f && this.headCollisionDistance < this.headCollisionThresholdDistance)
+             {
+                 float fadeBlend = 1f - ((1f / this.headCollisionThresholdDistance) * this.headCollisionDistance);
+                 renderFadeBlend(rgb, fadeBlend);
+                 //this.mc.printChatMessage("Collision in " + fadeBlend);
+             }
+             //else
+                 //this.mc.printChatMessage("No collision");
+         }
+    }
+
+    // Thanks to mhagain
+    public void renderFadeBlend (Color3f rgb, float fadeAlpha)
+    {
+        GL11.glEnable(GL11.GL_BLEND);
+        GL11.glEnable(GL11.GL_ALPHA_TEST);
+        GL11.glDisable(GL11.GL_CULL_FACE);
+        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+        GL11.glDisable(GL11.GL_DEPTH_TEST);
+        GL11.glDisable(GL11.GL_TEXTURE_2D);
+
+        GL11.glMatrixMode(GL11.GL_PROJECTION);
+        GL11.glPushMatrix();
+        GL11.glLoadIdentity();
+
+        // when laying out a 2D view, sometimes "top-left is the origin" makes more sense.
+        // it is the direction i read in, after all.  live with it, weenies.
+        GL11.glOrtho(0, this.mc.displayWidth, this.mc.displayHeight, 0, -1, 1);
+
+        GL11.glMatrixMode(GL11.GL_MODELVIEW);
+        GL11.glPushMatrix();
+        GL11.glLoadIdentity();
+
+        GL11.glColor4f(rgb.x, rgb.y, rgb.z, fadeAlpha);
+
+        GL11.glBegin(GL11.GL_QUADS);
+
+        GL11.glVertex3f(0, 0, 0);
+        GL11.glVertex3f(this.mc.displayWidth, 0, 0);
+        GL11.glVertex3f(this.mc.displayWidth, this.mc.displayHeight, 0);
+        GL11.glVertex3f(0, this.mc.displayHeight, 0);
+
+        GL11.glEnd();
+
+        GL11.glDisable(GL11.GL_BLEND);
+        GL11.glEnable(GL11.GL_DEPTH_TEST);
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+
+        GL11.glMatrixMode(GL11.GL_PROJECTION);
+        GL11.glPopMatrix();
+
+        GL11.glMatrixMode(GL11.GL_MODELVIEW);
+        GL11.glPopMatrix();
+    }
+
+    public void drawLine(Vec3 start, Vec3 end)
+    {
+        GL11.glEnable(GL11.GL_BLEND);
+        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+        GL11.glColor4f(0.0F, 0.0F, 0.0F, 0.4F);
+        GL11.glLineWidth(6.0F);
+        GL11.glDisable(GL11.GL_TEXTURE_2D);
+        GL11.glDepthMask(false);
+
+        Tessellator var2 = Tessellator.instance;
+        var2.startDrawing(GL11.GL_LINE_STRIP);
+        var2.addVertex(start.xCoord, start.yCoord, start.zCoord);
+        var2.addVertex(end.xCoord, end.yCoord, end.zCoord);
+        var2.draw();
+
+        GL11.glDepthMask(true);
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+        GL11.glDisable(GL11.GL_BLEND);
+    }
 }
